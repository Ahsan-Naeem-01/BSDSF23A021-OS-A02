
#### Q1. What is the crucial difference between the stat() and lstat() system calls? In the context of the ls command, when is it more appropriate to use lstat()?

Ans. The crucial difference between stat() and lstat() is how they handle symbolic links. The stat() system call returns information about the target file that a symbolic link points to, while lstat() returns information about the link itself. In simple words, stat() follows the link to see the file it points to, but lstat() looks at the link as it is. In the context of the ls command, it is more appropriate to use lstat() when listing files because ls -l wants to show details about symbolic links themselves, such as the link name, its permissions, and where it points, rather than the properties of the file the link points to. This way, symbolic links are displayed correctly instead of showing information about their target files.
#### Q2. The st_mode field in struct stat is an integer that contains both the file type (e.g., regular file, directory) and the permission bits. Explain how you can use bitwise operators (like &) and predefined macros (like S_IFDIR or S_IRUSR) to extract this information.

Ans. The st_mode field in struct stat contains information about both the file type and the file permissions in a single integer. To extract the file type, we use the bitwise AND operator & with the mask S_IFMT. This isolates the bits that represent the file type, which can then be compared with predefined macros like S_IFDIR for directories, S_IFREG for regular files, or S_IFLNK for symbolic links. For example, (st.st_mode & S_IFMT) == S_IFDIR checks if the file is a directory.  

Similarly, the permission bits can be extracted using & with macros such as S_IRUSR (owner read), S_IWUSR (owner write), S_IXUSR (owner execute), and corresponding macros for group and others. For instance, (st.st_mode & S_IRUSR) checks if the owner has read permission. Using bitwise AND in this way allows you to selectively check which permissions are set and what type of file you are dealing with.

#### Q3. Explain the general logic for printing items in a "down then across" columnar format. Why is a simple single loop through the list of filenames insufficient for this task?

Ans. In a “down then across” column layout, the filenames are printed vertically down each column before moving to the next column, instead of going straight across the screen. This means we must carefully decide how many rows and columns can fit on the terminal and then print the items row by row. For each row, we print one item from each column by jumping through the list using calculated positions. A simple single loop through the filenames is not enough because it would only print all the items in one long column from top to bottom, without arranging them neatly into multiple columns across the screen.


#### Q4. What is the purpose of the ioctl system call in this context? What would be the limitations of your program if you only used a fixed-width fallback (e.g., 80 columns) instead of detecting the terminal size?

Ans. In this context, the purpose of the ioctl system call is to get the current width of the terminal window so that the program can automatically adjust how many columns of filenames it can display. This makes the output of the ls command flexible — if the user resizes the terminal, the number of columns will change accordingly to fit the screen properly. If we only used a fixed-width fallback, like assuming the terminal is always 80 characters wide, the output would not adjust to different terminal sizes. This could cause problems such as filenames being cut off or leaving too much empty space when the terminal is wider or narrower than expected.

#### Q5. Compare the implementation complexity of the "down then across" (vertical) printing logic versus the "across" (horizontal) printing logic. Which one requires more pre-calculation and why?

Ans. The "down then across" (vertical) printing logic is more complex than the "across" (horizontal) logic because it requires more pre-calculation to correctly place each filename in its proper position. In the vertical format, you must first figure out how many rows and columns are needed, then carefully calculate which filenames go into which position using formulas like index = row + column * num_rows. This means you can’t simply loop through the list—you need to control the order of printing based on both rows and columns. In contrast, the horizontal printing logic is simpler because you can just loop through the filenames one by one, printing them left to right and starting a new line whenever you reach the terminal width. Therefore, the vertical layout requires more planning and indexing, while the horizontal layout follows a straightforward printing flow.


#### Q5. Describe the strategy you used in your code to manage the different display modes (-l, -x, and default). How did your program decide which function to call for printing?  

Ans. In my code, I used a simple flag or state variable to manage the different display modes. When parsing command-line arguments using getopt(), I checked for the presence of specific options like -l and -x. Each option set the display mode flag to a corresponding value — for example, one value for long listing (-l), another for horizontal display (-x), and a default value for the normal “down then across” display. After reading all filenames into an array, the program checked this flag inside the main do_ls() function. Based on the flag’s value, it decided which display function to call — the long listing function for -l, the horizontal display function for -x, or the default column display function if no option was provided. This made the code organized, easy to extend, and ensured that only one display mode was active at a time.

#### Q6. Why is it necessary to read all directory entries into memory before you can sort them? What are the potential drawbacks of this approach for directories containing millions of files?

Ans. It is necessary to read all directory entries into memory before sorting because sorting algorithms like `qsort()` need access to the complete list of filenames at once. The program must first collect all the names, store them in an array, and then compare them with each other to arrange them in order. If the filenames were not stored in memory, the program would have to repeatedly reopen and reread the directory, which would be very slow and inefficient. However, this approach also has some drawbacks. For directories that contain millions of files, storing all filenames in memory can use a large amount of RAM and may even cause the program to run out of memory or become very slow. In such cases, the sorting process could become inefficient, and the system’s performance might be affected.


#### Q7. Explain the purpose and signature of the comparison function required by qsort(). How does it work, and why must it take const void * arguments?

Ans. The comparison function in `qsort()` is used to tell the program how to compare two items while sorting. It has a fixed format, written as `int compare(const void *a, const void *b)`. The reason it uses `const void *` is that `qsort()` is a general function that can sort any type of data, not just one specific type like strings or numbers. Because of this, the function receives generic pointers and then you convert them to the correct type inside the function. For example, if you are sorting strings, you cast them to `const char **` and then use `strcmp()` to compare them. The comparison function returns a negative number if the first item should come before the second, zero if they are equal, and a positive number if the first should come after the second. This result helps `qsort()` arrange the items in the correct order.


